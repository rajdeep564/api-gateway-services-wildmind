import { 
  FalSubmitRequest, 
  FalSubmitResponse, 
  FalStatusResponse, 
  FalResultResponse, 
  FalImageResult 
} from '../types/fal';
import { ImageStorageService } from './imageStorageService';
import { logger } from '../utils/logger';
import { v4 as uuidv4 } from 'uuid';

// In-memory storage for request status (in production, use Redis or database)
const requestStore = new Map<string, {
  status: 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';
  images?: FalImageResult[];
  error?: string;
  originalImages?: string[];
}>();

export class FalService {
  static async submit(payload: FalSubmitRequest): Promise<FalSubmitResponse> {
    const requestId = uuidv4();
    
    logger.info({
      requestId,
      prompt: payload.prompt?.substring(0, 100) + '...',
      model: payload.model,
      numImages: payload.num_images || 1
    }, 'FAL image generation request submitted');

    // Store initial status
    requestStore.set(requestId, { status: 'IN_PROGRESS' });

    // Start image generation in background (don't await)
    this.generateImagesInBackground(requestId, payload).catch(error => {
      logger.error({ requestId, error: error.message }, 'Background image generation failed');
      requestStore.set(requestId, { 
        status: 'FAILED', 
        error: error.message 
      });
    });

    return {
      request_id: requestId,
      status: 'IN_PROGRESS'
    };
  }

  static async getStatus(requestId: string): Promise<FalStatusResponse> {
    const request = requestStore.get(requestId);
    
    if (!request) {
      throw new Error('Request not found');
    }

    return {
      status: request.status,
      request_id: requestId,
      logs: [],
      metrics: {}
    };
  }

  static async getResult(requestId: string): Promise<FalResultResponse> {
    const request = requestStore.get(requestId);
    
    if (!request) {
      throw new Error('Request not found');
    }

    if (request.status === 'FAILED') {
      return {
        status: 'error',
        images: [],
        request_id: requestId
      };
    }

    if (request.status === 'IN_PROGRESS') {
      throw new Error('Request still in progress');
    }

    return {
      status: 'success',
      images: request.images || [],
      request_id: requestId
    };
  }

  private static async generateImagesInBackground(
    requestId: string, 
    payload: FalSubmitRequest
  ): Promise<void> {
    try {
      logger.info({ requestId }, 'Starting image generation with FAL API');

      // Call FAL API
      const falResponse = await fetch('https://fal.run/fal-ai/flux/schnell', {
        method: 'POST',
        headers: {
          'Authorization': `Key ${process.env.FAL_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          prompt: payload.prompt,
          image_size: payload.image_size || 'square_hd',
          num_images: payload.num_images || 1,
          guidance_scale: payload.guidance_scale || 7.5,
          num_inference_steps: payload.num_inference_steps || 28,
          enable_safety_checker: payload.enable_safety_checker !== false,
          seed: payload.seed,
          sync_mode: true // Get results immediately
        })
      });

      if (!falResponse.ok) {
        const errorText = await falResponse.text();
        throw new Error(`FAL API error: ${falResponse.status} ${errorText}`);
      }

      const falResult = await falResponse.json();
      
      logger.info({
        requestId,
        imageCount: falResult.images?.length || 0
      }, 'Images generated by FAL API');

      // Extract image URLs from FAL response
      const originalImageUrls = falResult.images?.map((img: any) => img.url) || [];
      
      if (originalImageUrls.length === 0) {
        throw new Error('No images generated by FAL API');
      }

      // Upload to Zata AI
      logger.info({ requestId, imageCount: originalImageUrls.length }, 'Uploading images to Zata');
      
      const zataUploadResults = await ImageStorageService.downloadAndUploadMultipleToZata(
        originalImageUrls,
        originalImageUrls.map((_: string, index: number) => 
          ImageStorageService.generateImageKey(payload.prompt, 'fal-flux-schnell', index)
        )
      );

      // Create final image results
      const images: FalImageResult[] = originalImageUrls.map((originalUrl: string, index: number) => {
        const zataResult = zataUploadResults[index];
        const imageId = `${requestId}-${index}`;
        
        if (zataResult.success && zataResult.zataUrl) {
          return {
            id: imageId,
            url: zataResult.zataUrl, // Frontend gets Zata URL
            originalUrl,
            zataUrl: zataResult.zataUrl,
            zataKey: zataResult.zataKey,
            firebaseUrl: zataResult.zataUrl // For compatibility with existing frontend
          };
        } else {
          // Fallback to original URL if Zata upload failed
          logger.warn({
            requestId,
            imageIndex: index,
            originalUrl,
            error: zataResult.error
          }, 'Zata upload failed, using original URL');
          
          return {
            id: imageId,
            url: originalUrl,
            originalUrl,
            firebaseUrl: originalUrl // For compatibility
          };
        }
      });

      // Update status to completed
      requestStore.set(requestId, {
        status: 'COMPLETED',
        images,
        originalImages: originalImageUrls
      });

      logger.info({
        requestId,
        imageCount: images.length,
        zataSuccessful: images.filter(img => img.zataUrl).length
      }, 'Image generation and upload completed');

    } catch (error: any) {
      logger.error({
        requestId,
        error: error.message,
        stack: error.stack
      }, 'Image generation failed');
      
      requestStore.set(requestId, {
        status: 'FAILED',
        error: error.message
      });
    }
  }

  // Cleanup old requests (call this periodically)
  static cleanup(): void {
    const now = Date.now();
    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
    
    for (const [requestId, request] of requestStore.entries()) {
      // This is a simple cleanup - in production, you'd store timestamps
      if (requestStore.size > 1000) { // Keep only latest 1000 requests
        requestStore.delete(requestId);
      }
    }
  }
}
